lib/features/service_opportunities/models/project_model.dart: |
  import 'package:json_annotation/json_annotation.dart';
  
  part 'project_model.g.dart';
  
  @JsonSerializable()
  class ProjectModel {
    final String id;
    final String title;
    final String description;
    final String organizerId;
    final String? organizerName;
    final String? organizerImageUrl;
    final String location;
    final double? latitude;
    final double? longitude;
    final DateTime startDate;
    final DateTime endDate;
    final int minVolunteers;
    final int maxVolunteers;
    final int currentVolunteers;
    final List<String> requiredSkills;
    final List<String> causeAreas;
    final List<String>? tags;
    final String status;
    final double? pointsMultiplier;
    final DateTime createdAt;
    final DateTime updatedAt;
    final List<String>? imageUrls;
    final bool isRecurring;
    final String? recurringPattern;
    
    const ProjectModel({
      required this.id,
      required this.title,
      required this.description,
      required this.organizerId,
      this.organizerName,
      this.organizerImageUrl,
      required this.location,
      this.latitude,
      this.longitude,
      required this.startDate,
      required this.endDate,
      required this.minVolunteers,
      required this.maxVolunteers,
      required this.currentVolunteers,
      required this.requiredSkills,
      required this.causeAreas,
      this.tags,
      required this.status,
      this.pointsMultiplier,
      required this.createdAt,
      required this.updatedAt,
      this.imageUrls,
      required this.isRecurring,
      this.recurringPattern,
    });
    
    // Whether the project is at capacity
    bool get isAtCapacity => currentVolunteers >= maxVolunteers;
    
    // Whether the project is in the future
    bool get isFuture => startDate.isAfter(DateTime.now());
    
    // Whether the project is in progress
    bool get isInProgress => 
        startDate.isBefore(DateTime.now()) && endDate.isAfter(DateTime.now());
    
    // Whether the project is completed
    bool get isCompleted => endDate.isBefore(DateTime.now());
    
    // Factory method to create project from JSON
    factory ProjectModel.fromJson(Map<String, dynamic> json) => 
        _$ProjectModelFromJson(json);
    
    // Method to convert project to JSON
    Map<String, dynamic> toJson() => _$ProjectModelToJson(this);
  }

lib/features/service_opportunities/models/project_slot_model.dart: |
  import 'package:json_annotation/json_annotation.dart';
  
  part 'project_slot_model.g.dart';
  
  @JsonSerializable()
  class ProjectSlotModel {
    final String id;
    final String projectId;
    final DateTime startTime;
    final DateTime endTime;
    final int maxCapacity;
    final int currentVolunteers;
    final String status;
    final List<String>? requiredRoles;
    
    const ProjectSlotModel({
      required this.id,
      required this.projectId,
      required this.startTime,
      required this.endTime,
      required this.maxCapacity,
      required this.currentVolunteers,
      required this.status,
      this.requiredRoles,
    });
    
    // Whether the slot is at capacity
    bool get isAtCapacity => currentVolunteers >= maxCapacity;
    
    // Whether the slot is in the future
    bool get isFuture => startTime.isAfter(DateTime.now());
    
    // Whether the slot is in progress
    bool get isInProgress => 
        startTime.isBefore(DateTime.now()) && endTime.isAfter(DateTime.now());
    
    // Whether the slot is completed
    bool get isCompleted => endTime.isBefore(DateTime.now());
    
    // Duration of the slot in hours
    double get durationHours => 
        endTime.difference(startTime).inMinutes / 60.0;
    
    // Factory method to create slot from JSON
    factory ProjectSlotModel.fromJson(Map<String, dynamic> json) => 
        _$ProjectSlotModelFromJson(json);
    
    // Method to convert slot to JSON
    Map<String, dynamic> toJson() => _$ProjectSlotModelToJson(this);
  }

lib/core/services/project_service.dart: |
  import 'dart:async';
  import 'package:flutter/foundation.dart';
  import 'package:serve_to_be_free/core/services/mqtt_service.dart';
  import 'package:serve_to_be_free/features/service_opportunities/models/project_model.dart';
  import 'package:serve_to_be_free/features/service_opportunities/models/project_slot_model.dart';
  
  class ProjectService {
    final MqttService _mqttService;
    
    // MQTT Topics
    static const String _projectRequestTopic = 'stbf/project/request';
    static const String _projectResponseTopic = 'stbf/project/response';
    
    ProjectService(this._mqttService) {
      _init();
    }
    
    Future<void> _init() async {
      // Subscribe to project response topic
      await _mqttService.subscribe(_projectResponseTopic);
    }
    
    // Get featured projects
    Future<List<ProjectModel>> getFeaturedProjects() async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'get_featured_projects',
          }
        );
        
        if (response['status'] == 'success') {
          final List<dynamic> projectsJson = response['projects'];
          return projectsJson.map((json) => ProjectModel.fromJson(json)).toList();
        } else {
          throw Exception(response['message'] ?? 'Failed to get featured projects');
        }
      } catch (e) {
        throw Exception('Failed to get featured projects: $e');
      }
    }
    
    // Search projects with filters
    Future<Map<String, dynamic>> searchProjects({
      String? query,
      List<String>? causeAreas,
      DateTime? startDate,
      DateTime? endDate,
      String? location,
      double? latitude,
      double? longitude,
      double? radius,
      List<String>? requiredSkills,
      String? status,
      int page = 1,
      int pageSize = 10,
    }) async {
      try {
        final requestData = {
          'action': 'search_projects',
          'page': page,
          'pageSize': pageSize,
        };
        
        if (query != null && query.isNotEmpty) {
          requestData['query'] = query;
        }
        
        if (causeAreas != null && causeAreas.isNotEmpty) {
          requestData['causeAreas'] = causeAreas;
        }
        
        if (startDate != null) {
          requestData['startDate'] = startDate.toIso8601String();
        }
        
        if (endDate != null) {
          requestData['endDate'] = endDate.toIso8601String();
        }
        
        if (location != null && location.isNotEmpty) {
          requestData['location'] = location;
        }
        
        if (latitude != null && longitude != null && radius != null) {
          requestData['latitude'] = latitude;
          requestData['longitude'] = longitude;
          requestData['radius'] = radius;
        }
        
        if (requiredSkills != null && requiredSkills.isNotEmpty) {
          requestData['requiredSkills'] = requiredSkills;
        }
        
        if (status != null && status.isNotEmpty) {
          requestData['status'] = status;
        }
        
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          requestData
        );
        
        if (response['status'] == 'success') {
          final List<dynamic> projectsJson = response['projects'];
          final projects = projectsJson.map((json) => ProjectModel.fromJson(json)).toList();
          
          return {
            'projects': projects,
            'totalProjects': response['totalProjects'],
            'totalPages': response['totalPages'],
            'currentPage': response['currentPage'],
          };
        } else {
          throw Exception(response['message'] ?? 'Failed to search projects');
        }
      } catch (e) {
        throw Exception('Failed to search projects: $e');
      }
    }
    
    // Get project details by ID
    Future<ProjectModel> getProjectById(String projectId) async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'get_project',
            'projectId': projectId,
          }
        );
        
        if (response['status'] == 'success') {
          return ProjectModel.fromJson(response['project']);
        } else {
          throw Exception(response['message'] ?? 'Failed to get project');
        }
      } catch (e) {
        throw Exception('Failed to get project: $e');
      }
    }
    
    // Get project slots
    Future<List<ProjectSlotModel>> getProjectSlots(String projectId) async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'get_project_slots',
            'projectId': projectId,
          }
        );
        
        if (response['status'] == 'success') {
          final List<dynamic> slotsJson = response['slots'];
          return slotsJson.map((json) => ProjectSlotModel.fromJson(json)).toList();
        } else {
          throw Exception(response['message'] ?? 'Failed to get project slots');
        }
      } catch (e) {
        throw Exception('Failed to get project slots: $e');
      }
    }
    
    // Register for a project
    Future<bool> registerForProject(
      String userId,
      String projectId,
      String? slotId,
      int numberOfVolunteers,
    ) async {
      try {
        final requestData = {
          'action': 'register_for_project',
          'userId': userId,
          'projectId': projectId,
          'numberOfVolunteers': numberOfVolunteers,
        };
        
        if (slotId != null) {
          requestData['slotId'] = slotId;
        }
        
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          requestData
        );
        
        return response['status'] == 'success';
      } catch (e) {
        throw Exception('Failed to register for project: $e');
      }
    }
    
    // Cancel project registration
    Future<bool> cancelProjectRegistration(
      String userId,
      String projectId,
      String? slotId,
    ) async {
      try {
        final requestData = {
          'action': 'cancel_registration',
          'userId': userId,
          'projectId': projectId,
        };
        
        if (slotId != null) {
          requestData['slotId'] = slotId;
        }
        
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          requestData
        );
        
        return response['status'] == 'success';
      } catch (e) {
        throw Exception('Failed to cancel registration: $e');
      }
    }
    
    // Create a new project
    Future<ProjectModel> createProject(Map<String, dynamic> projectData) async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'create_project',
            'projectData': projectData,
          }
        );
        
        if (response['status'] == 'success') {
          return ProjectModel.fromJson(response['project']);
        } else {
          throw Exception(response['message'] ?? 'Failed to create project');
        }
      } catch (e) {
        throw Exception('Failed to create project: $e');
      }
    }
    
    // Update an existing project
    Future<ProjectModel> updateProject(
      String projectId,
      Map<String, dynamic> updates,
    ) async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'update_project',
            'projectId': projectId,
            'updates': updates,
          }
        );
        
        if (response['status'] == 'success') {
          return ProjectModel.fromJson(response['project']);
        } else {
          throw Exception(response['message'] ?? 'Failed to update project');
        }
      } catch (e) {
        throw Exception('Failed to update project: $e');
      }
    }
    
    // Get cause areas
    Future<List<String>> getCauseAreas() async {
      try {
        final response = await _mqttService.request(
          _projectRequestTopic,
          _projectResponseTopic,
          {
            'action': 'get_cause_areas',
          }
        );
        
        if (response['status'] == 'success') {
          final List<dynamic> causeAreas = response['causeAreas'];
          return causeAreas.map((area) => area.toString()).toList();
        } else {
          throw Exception(response['message'] ?? 'Failed to get cause areas');
        }
      } catch (e) {
        throw Exception('Failed to get cause areas: $e');
      }
    }
  }
  
  class ProjectProvider with ChangeNotifier {
    final ProjectService _projectService;
    
    List<ProjectModel> _featuredProjects = [];
    List<ProjectModel> _searchResults = [];
    ProjectModel? _currentProject;
    List<ProjectSlotModel> _currentProjectSlots = [];
    List<String> _causeAreas = [];
    bool _isLoading = false;
    int _totalProjects = 0;
    int _currentPage = 1;
    int _totalPages = 1;
    
    // Getters
    List<ProjectModel> get featuredProjects => _featuredProjects;
    List<ProjectModel> get searchResults => _searchResults;
    ProjectModel? get currentProject => _currentProject;
    List<ProjectSlotModel> get currentProjectSlots => _currentProjectSlots;
    List<String> get causeAreas => _causeAreas;
    bool get isLoading => _isLoading;
    int get totalProjects => _totalProjects;
    int get currentPage => _currentPage;
    int get totalPages => _totalPages;
    
    ProjectProvider(this._projectService);
    
    // Fetch featured projects
    Future<void> fetchFeaturedProjects() async {
      _isLoading = true;
      notifyListeners();
      
      try {
        _featuredProjects = await _projectService.getFeaturedProjects();
        _isLoading = false;
        notifyListeners();
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Search projects
    Future<void> searchProjects({
      String? query,
      List<String>? causeAreas,
      DateTime? startDate,
      DateTime? endDate,
      String? location,
      double? latitude,
      double? longitude,
      double? radius,
      List<String>? requiredSkills,
      String? status,
      int page = 1,
      bool reset = true,
    }) async {
      _isLoading = true;
      if (reset) {
        _searchResults = [];
      }
      notifyListeners();
      
      try {
        final result = await _projectService.searchProjects(
          query: query,
          causeAreas: causeAreas,
          startDate: startDate,
          endDate: endDate,
          location: location,
          latitude: latitude,
          longitude: longitude,
          radius: radius,
          requiredSkills: requiredSkills,
          status: status,
          page: page,
        );
        
        final List<ProjectModel> projects = result['projects'];
        _totalProjects = result['totalProjects'];
        _totalPages = result['totalPages'];
        _currentPage = result['currentPage'];
        
        if (reset) {
          _searchResults = projects;
        } else {
          _searchResults.addAll(projects);
        }
        
        _isLoading = false;
        notifyListeners();
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Load more search results
    Future<void> loadMoreSearchResults({
      String? query,
      List<String>? causeAreas,
      DateTime? startDate,
      DateTime? endDate,
      String? location,
      double? latitude,
      double? longitude,
      double? radius,
      List<String>? requiredSkills,
      String? status,
    }) async {
      if (_currentPage < _totalPages && !_isLoading) {
        await searchProjects(
          query: query,
          causeAreas: causeAreas,
          startDate: startDate,
          endDate: endDate,
          location: location,
          latitude: latitude,
          longitude: longitude,
          radius: radius,
          requiredSkills: requiredSkills,
          status: status,
          page: _currentPage + 1,
          reset: false,
        );
      }
    }
    
    // Get project details
    Future<void> fetchProjectDetails(String projectId) async {
      _isLoading = true;
      notifyListeners();
      
      try {
        _currentProject = await _projectService.getProjectById(projectId);
        _currentProjectSlots = await _projectService.getProjectSlots(projectId);
        _isLoading = false;
        notifyListeners();
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Register for a project
    Future<bool> registerForProject(
      String userId,
      String projectId,
      String? slotId,
      int numberOfVolunteers,
    ) async {
      _isLoading = true;
      notifyListeners();
      
      try {
        final result = await _projectService.registerForProject(
          userId,
          projectId,
          slotId,
          numberOfVolunteers,
        );
        
        if (result && _currentProject?.id == projectId) {
          // Refresh project details to get updated counts
          await fetchProjectDetails(projectId);
        }
        
        _isLoading = false;
        notifyListeners();
        return result;
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Cancel project registration
    Future<bool> cancelProjectRegistration(
      String userId,
      String projectId,
      String? slotId,
    ) async {
      _isLoading = true;
      notifyListeners();
      
      try {
        final result = await _projectService.cancelProjectRegistration(
          userId,
          projectId,
          slotId,
        );
        
        if (result && _currentProject?.id == projectId) {
          // Refresh project details to get updated counts
          await fetchProjectDetails(projectId);
        }
        
        _isLoading = false;
        notifyListeners();
        return result;
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Create a new project
    Future<ProjectModel> createProject(Map<String, dynamic> projectData) async {
      _isLoading = true;
      notifyListeners();
      
      try {
        final project = await _projectService.createProject(projectData);
        _isLoading = false;
        notifyListeners();
        return project;
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Update an existing project
    Future<ProjectModel> updateProject(
      String projectId,
      Map<String, dynamic> updates,
    ) async {
      _isLoading = true;
      notifyListeners();
      
      try {
        final project = await _projectService.updateProject(projectId, updates);
        
        if (_currentProject?.id == projectId) {
          _currentProject = project;
        }
        
        _isLoading = false;
        notifyListeners();
        return project;
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
    
    // Fetch cause areas
    Future<void> fetchCauseAreas() async {
      if (_causeAreas.isNotEmpty) return;
      
      _isLoading = true;
      notifyListeners();
      
      try {
        _causeAreas = await _projectService.getCauseAreas();
        _isLoading = false;
        notifyListeners();
      } catch (e) {
        _isLoading = false;
        notifyListeners();
        rethrow;
      }
    }
  }

lib/features/service_opportunities/screens/project_listing_screen.dart: |
  import 'package:flutter/material.dart';
  import 'package:provider/provider.dart';
  import 'package:serve_to_be_free/core/services/project_service.dart';
  import 'package:serve_to_be_free/core/theme/app_theme.dart';
  import 'package:serve_to_be_free/features/service_opportunities/widgets/project_card.dart';
  import 'package:serve_to_be_free/features/service_opportunities/widgets/search_filter_bar.dart';
  import 'package:serve_to_be_free/features/service_opportunities/screens/project_detail_screen.dart';

  class ProjectListingScreen extends StatefulWidget {
    const ProjectListingScreen({Key? key}) : super(key: key);

    @override
    State<ProjectListingScreen> createState() => _ProjectListingScreenState();
  }

  class _ProjectListingScreenState extends State<ProjectListingScreen> {
    final ScrollController _scrollController = ScrollController();
    String? _searchQuery;
    List<String>? _selectedCauseAreas;
    DateTime? _selectedDate;
    
    @override
    void initState() {
      super.initState();
      _loadInitialData();
      _setupScrollListener();
    }
    
    @override
    void dispose() {
      _scrollController.dispose();
      super.dispose();
    }
    
    void _loadInitialData() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final projectProvider = Provider.of<ProjectProvider>(context, listen: false);
        projectProvider.fetchCauseAreas();
        projectProvider.fetchFeaturedProjects();
        projectProvider.searchProjects();
      });
    }
    
    void _setupScrollListener() {
      _scrollController.addListener(() {
        if (_scrollController.position.pixels >= 
            _scrollController.position.maxScrollExtent - 200) {
          _loadMoreProjects();
        }
      });
    }
    
    void _loadMoreProjects() {
      Provider.of<ProjectProvider>(context, listen: false).loadMoreSearchResults(
        query: _searchQuery,
        causeAreas: _selectedCauseAreas,
        startDate: _selectedDate,
      );
    }
    
    void _handleSearch(String? query) {
      setState(() {
        _searchQuery = query;
      });
      
      Provider.of<ProjectProvider>(context, listen: false).searchProjects(
        query: query,
        causeAreas: _selectedCauseAreas,
        startDate: _selectedDate,
      );
    }
    
    void _handleFilterChange({
      List<String>? causeAreas,
      DateTime? date,
    }) {
      setState(() {
        _selectedCauseAreas = causeAreas;
        _selectedDate = date;
      });
      
      Provider.of<ProjectProvider>(context, listen: false).searchProjects(
        query: _searchQuery,
        causeAreas: causeAreas,
        startDate: date,
      );
    }
    
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Service Opportunities'),
          elevation: 0,
        ),
        body: Column(
          children: [
            // Search and Filter Bar
            SearchFilterBar(
              onSearch: _handleSearch,
              onFilterChange: _handleFilterChange,
            ),
            
            // Projects List
            Expanded(
              child: Consumer<ProjectProvider>(
                builder: (context, projectProvider, child) {
                  if (projectProvider.isLoading && 
                      projectProvider.searchResults.isEmpty &&
                      projectProvider.featuredProjects.isEmpty) {
                    return const Center(
                      child: CircularProgressIndicator(),
                    );
                  }
                  
                  return CustomScrollView(
                    controller: _scrollController,
                    slivers: [
                      // Featured Projects
                      if (projectProvider.featuredProjects.isNotEmpty && 
                          _searchQuery == null && 
                          _selectedCauseAreas == null &&
                          _selectedDate == null)
                        SliverToBoxAdapter(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const Padding(
                                padding: EdgeInsets.fromLTRB(16, 16, 16, 8),
                                child: Text(
                                  'Featured Projects',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                              SizedBox(
                                height: 220,
                                child: ListView.builder(
                                  padding: const EdgeInsets.symmetric(horizontal: 16),
                                  scrollDirection: Axis.horizontal,
                                  itemCount: projectProvider.featuredProjects.length,
                                  itemBuilder: (context, index) {
                                    final project = projectProvider.featuredProjects[index];
                                    return SizedBox(
                                      width: 280,
                                      child: ProjectCard(
                                        project: project,
                                        isFeatured: true,
                                        onTap: () {
                                          Navigator.push(
                                            context,
                                            MaterialPageRoute(
                                              builder: (context) => ProjectDetailScreen(
                                                projectId: project.id,
                                              ),
                                            ),
                                          );
                                        },
                                      ),
                                    );
                                  },
                                ),
                              ),
                            ],
                          ),
                        ),
                      
                      // All Projects or Search Results
                      SliverToBoxAdapter(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                          child: Text(
                            _searchQuery != null || _selectedCauseAreas != null || _selectedDate != null
                                ? 'Search Results (${projectProvider.totalProjects})'
                                : 'All Projects',
                            style: const TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                      
                      if (projectProvider.searchResults.isEmpty && !projectProvider.isLoading)
                        const SliverToBoxAdapter(
                          child: Padding(
                            padding: EdgeInsets.all(16.0),
                            child: Center(
                              child: Text(
                                'No projects found. Try adjusting your filters.',
                                style: TextStyle(
                                  color: AppTheme.textSecondaryDarkColor,
                                ),
                              ),
                            ),
                          ),
                        ),
                      
                      SliverPadding(
                        padding: const EdgeInsets.all(16),
                        sliver: SliverGrid(
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 2,
                            childAspectRatio: 0.75,
                            crossAxisSpacing: 16,
                            mainAxisSpacing: 16,
                          ),
                          delegate: SliverChildBuilderDelegate(
                            (context, index) {
                              final project = projectProvider.searchResults[index];
                              return ProjectCard(
                                project: project,
                                isFeatured: false,
                                onTap: () {
                                  Navigator.push(
                                    context,
                                    MaterialPageRoute(
                                      builder: (context) => ProjectDetailScreen(
                                        projectId: project.id,
                                      ),
                                    ),
                                  );
                                },
                              );
                            },
                            childCount: projectProvider.searchResults.length,
                          ),
                        ),
                      ),
                      
                      // Loading indicator at the bottom when loading more
                      if (projectProvider.isLoading && 
                          projectProvider.searchResults.isNotEmpty)
                        const SliverToBoxAdapter(
                          child: Padding(
                            padding: EdgeInsets.all(16.0),
                            child: Center(
                              child: CircularProgressIndicator(),
                            ),
                          ),
                        ),
                    ],
                  );
                },
              ),
            ),
          ],
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            // Navigate to create project screen
          },
          child: const Icon(Icons.add),
          tooltip: 'Create Project',
        ),
      );
    }
  }
